# 7 - Win32 Buffer Overflow Exploitation

## 7.1 - Replicating the Crash

From our fuzzer output, we can deduce that SLMail has a buffer overflow vulnerability when a **PASS** command with a password containing about 2700 bytes is sent to it. Our first task in the exploitation process is to write a simple script that will replicate our observed crash, without having to run the fuzzer each time. Our script would look similar to the following.

##### [fuzzer.py]()

## 7.2 - Controlling EIP

Getting control of the EIP register is a crucial step of exploit development. The EIP register is like the reins on a running horse. Pulling the reins left will make the application go one way, while pulling then right will make it go the other. For this reason, it i vital that we locate those 4 *A*'s that overwrite our EIP register in the buffer. The are two common ways to do this:

### 7.2.1 - Binary Tree Analysis

Instead of 2700 *A*'s, we send 1350 *A*'s and 1350 *B*'s. If EIP is overwritten by *B*'s, we know the four bytes reside in the second half of the buffer. We then chande the 1350 *B*'s to 675 *B*'s and 675 *C*'s, and send the buffer again. If EIP is overwritten by *C*'s, we know that the four bytes reside in the 2000-2700 byte range. We continue splitting the specific buffer until we reach the exact four bytes that overwrite EIP.

### 7.2.2. - Sending a Unique String

The faster method of identifying these four bytes is to send a unique string of 2700 bytes, identify the 4 bytes that overwrite EIP, and then locate those four bytes in our unique buffer.

#### **Pattern Create**

The **pattern_create.rb** is a Ruby tool for creating and locating such buffers, and can be found as part of the Metasploit Framework exploit development scripts.

```
root@kali:~# locate pattern_create
/usr/share/metasploit-framework/tools/pattern_create.rb
root@kali:~# /usr/share/metasploit-framework/tools/pattern_create.rb 2700
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3A	
...
```

Plugging this buffer insted of our 2700 *A*'s into our Python exploit produces an EIP overwrite that looks similar to the following image. Note both the  **ESP** and **EIP** register values in this next crash.

![ EIP  Overwritten  by  the  Unique  Pattern](https://image.ibb.co/cYS5C7/01.png)

The EIP register has been overwritten with the hex bytes **39 69 44 38** (equivalent to the string **8Dj9**). We can now use the companion to **pattern_create**, **pattern_offset.rb**, to discover the offset of these specific 4 bytes in our unique byte string.

```
root@kali:~# /usr/share/metasploit-framework/tools/pattern_offset.rb 39694438
[*] Exact match at offset 2906
```

The **pattern_offset.rb** script reports these 4 bytes being located at offset 2606 of the 2700 bytes. Let's translate this to a new modified buffer string, and see if we can control the EIP register. We modify our exploit to contain the following buffer string.

Sending this new buffer to the SLMail POP3 server produces the following crash in our debugger.

* **ESP**: 024FA128
* **EIP**: 42424242

This time, the ESP has a different value than our first crash. The EIP register is cleanly overwritten by *B*'s (**\x42**), signifying that our calculation were correct, and we can now control the execution flow of the SLMail application. Where, exactly, do we redirect the execution flw, now that we control the EIP register?

Part of our buffer can contain the code (or **shellcode**) we would like to have executed by the SLmail application, such as a reverse shell. Our next steps will involve examining and prepating the space for this shellcode, and figuring out a way to redirect code execution to it.

## Exercicies

1. Write a standalone script to replicate the crash

> [scripts](https://github.com/cdojo/OSCP/tree/master/07-Win32%20Buffer%20Overflow%20Exploitation/scripts)

2. Determine the offset of EIP for the data that is being sent.

> ...

3. Update your standalone script to place a unique value into EIP, to ensure your offsets are corrent.

> ...

## 7.3 - Locating Space for Your Shellcode

The Metasploit Framework can automatically generate shellcode payloads. A standard reverse shell payload requires about 350-400 bytes of space. Looking back at the last crash, we can see that the ESP register points directly to the beginning of our buffer of *C*'s. This seems like a convenient location to place our shellcode as it will be easily accessible to us through the ESP register later on.

![ESP is Pointing to the Buffer of CÊ¹s](https://image.ibb.co/gMLLen/02.png)

However, on counting those *C*'s, we notice that we have a total of **74** of them - not enough to contain a 350-byte payload. One easy way out of this is simply to try to increase our buffer length from 2700 bytes to 3500 bytes, and see if this results in a larger space for our shellcode.

```python
buffer = "A" * 2606 + "B" * 4 + "C" * (3500 - 2606 - 4)
```

Once the new, longer buffer is sent, we see the following in the debugger.

![Our Increased Buffer Length is Successful](https://preview.ibb.co/kdzDX7/03.png)

This simple trick has provided us with significantly more space to work with. Upon further examination, we see that a total of 424 bytes of free space are available to us to use for shellcode. Once again, notice how the address in ESP points to our buffer, and also take note that this address is not the same as the address from the previous crashes.

## 7.4 - Checking for Bad Characters

Depending on the application, vulnerability type, and protocols in use, there may be certain characters that are considered "bad" and should not be used in your buffer, or shellcode. One example of a common bad charecter is the **null byte** (**0x00**).

This character is considered bad because a null byte is also used to terminate a string copy operation, wich would effectively truncate our buffer to wherever the first null byte appears.

Another example of a bad character, specific to the POP3 PASS command, is the carriage return (**0x0D**), wich signifies to the application that the end of the password has been reachead.

An experienced exploit writer knows to check for bad chaacters, to prevent future problems. An easy way to do this is to send all possible characters, from **0x00** to **0xff**, as part of our buffer, and see how these characters are dealt with by the application, after the crash occurs.

##### Bad chars

```python
bad_chars = "\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0b\x0c\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18"
bad_chars += "\x19\x1a\x1b\x1c\x1d\x1e\x1f\x20\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30\x31"
bad_chars += "\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f\x40\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a"
bad_chars += "\x4b\x4c\x4d\x4e\x4f\x50\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f\x60\x61\x62\x63"
bad_chars += "\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c"
bad_chars += "\x7d\x7e\x7f\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90\x91\x92\x93\x94\x95"
bad_chars += "\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae"
bad_chars += "\xaf\xb0\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xc0\xc1\xc2\xc3\xc4\xc5\xc6\xc7"
bad_chars += "\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf\xe0"
bad_chars += "\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9"
bad_chars += "\xfa\xfb\xfc\xfd\xfe\xff"
```